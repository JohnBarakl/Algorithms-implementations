/*
 * Ονοματεπώνυμο: Μπαρακλιλής Ιωάννης.
 * ΑΕΜ: 3685.
 * Email: imparakl@csd.auth.gr
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Η κλάση Knapsack περιέχει τις μεθόδους με τις οποίες μπορεί να λυθεί το πρόβλημα της εκφώνησης της εργασίας
 * υλοποιώντας παραλλαγές του αλγορίθμου που λύνει το πρόβλημα του σακιδίου.
 * Η λύση του προβλήματος και η εμφάνιση της λύσης γίνεται μέσω της μεθόδου main().
 */
public class Knapsack {
    /**
     * Λύνει το πρώτο ζητούμενο της παραλλαγής του προβλήματος του σακιδίου που αρμόζει στην άσκηση.
     *
     * Συγκεκριμένα, υπολογίζει το ελάχιστο πλήθος των κουτιών που απαιτούνται για να γεμίσει πλήρως το εμπορευματοκιβώτιο
     * θεωρώντας άπειρες ποσότητες κουτιών (αγνοώντας δηλαδή τις διαθέσιμες ποσότητες) [unbounded case].
     *
     * Ο αλγόριθμος που χρησιμοποιείται είναι εκείνος που λύνει το πρόβλημα των νομισμάτων με απεριόριστο αριθμό αυτών.
     * Συγκεκριμένα, χρησιμοποιείται η bottom-up εκδοχή του που χρησιμοποιεί έναν πίνακα για να αποθηκεύσει τα ενδιάμεσα αποτελέσματα
     * της αναδρομικής εξίσωσης:                { άπειρο, άν η λύση είναι ανέφικτη σύμφωνα με τον ορισμό του προβλήματος δηλαδή για i = 0, j >= 1.
     *                              OPT(i, j) = { 0, για j = 0.
     *                                          { OPT(i - 1, j), για capacity(i) > j.
     *                                          { min( OPT(i - 1, j), 1 + OPT(i, j - capacity(i)) ), σε διαφορετικές περιπτώσεις.
     *
     * Η εξίσωση αυτή δίνει τον αριθμό ελάχιστο αριθμό κουτιών λαμβάνοντας υπόψη τα κουτιά 1, ..., i και χωρητικότητα j.
     * 
     * Ο πρώτος κλάδος της εξίσωσης ορίζει τις αδύνατες αρχικά περιπτώσεις που "μεταδίδονται" και στις υπόλοιπες που προκύπτουν στην πορεία.
     * Ο δεύτερος, για την τετριμμένη περίπτωση της κάλυψης μηδενικής χωρητικότητας με μηδενικά κουτιά.
     * Ο τρίτος, για αυθαίρετη μη-επιλογή i-ου κουτιού από τον αλγόριθμο εφόσον δεν μπορεί αυτό να γίνει λόγω φυσικού περιορισμού.
     * Ο τέταρτος, για επιλογή από τον αλγόριθμο για το αν συμφέρει η επιλογή επιπλέον i-ου κουτιού ή όχι και επιλογή πιο συμφέρουσας 
     *  (με μικρότερο αριθμό κουτιών) λύσης.
     *
     * @param containerTotalCapacity η διαθέσιμη χωρητικότητα του εμπορευματοκιβωτίου που πρέπει να γεμίσει πλήρως.
     * @param itemsCapacity πίνακας με τις χωρητικότητες κάθε κουτιού, η εκάστοτε i-η γραμμή αφορά το (i+1)-οστό αντικείμενο.
     * @return το ελάχιστο πλήθος των κουτιών που απαιτούνται για να γεμίσει πλήρως το εμπορευματοκιβώτιο. Άν το πρόβλημα
     * δεν λύνεται, επιστρέφεται -1.
     */
    public static int solveKnapsackUnlimited(int containerTotalCapacity, int[] itemsCapacity){
        // Πίνακας όπου το κάθε στοιχείο OPT[i][j] περιέχει το ελάχιστο πλήθος των κουτιών έχοντας λάβει υπόψην τα
        // στοιχεία 1, ..., i και με j την χωρητικότητα που καλύπτεται. Άν κάποιο στοιχείο OPT[i][j] έχει τιμή Integer.MAX_VALUE
        // (στην πράξη δεν υπάρχει το άπειρο οπότε χρησιμοποιώ την μεγαλύτερη δυνατή τιμή ακεραίου), αυτό σηματοδοτεί ότι
        // είναι αδύνατη κάλυψη χωρητικότητας j χρησιμοποιώντας τα στοιχεία 1, ..., i.
        // Έχει μέγεθος (itemsCapacity.length + 1)x(containerTotalCapacity + 1), δηλαδή πλήθος γραμμών ίσο με τα στοιχεία και πλήθος στηλών
        // ίσο με την χωρητικότητα που καλούμαστε να καλύψουμε, αν αγνοήσουμε την πρώτη γραμμή και πρώτη στήλη.
        int[][] OPT = new int[itemsCapacity.length + 1][containerTotalCapacity + 1];

        // Η πρώτη γραμμή, εξ' ορισμού, αντιστοιχεί στο μηδενικό στοιχείο και, εφόσον καλύπτει μηδενικό χώρο, δεν μπορεί να ληφθεί
        // υπόψη προς επιλογή. Εξαίρεση το πρώτο στοιχείο πρώτης γραμμής που, προφανώς, είναι δυνατή η κάλυψη μηδενικής
        // χωρητικότητας με μηδενικά κουτιά.
        // Κλάδος OPT(i, j) = άπειρο, άν η λύση είναι ανέφικτη σύμφωνα με τον ορισμό του προβλήματος δηλαδή για i = 0, j >= 1.
        for(int i = 1; i <= containerTotalCapacity; i++){
            OPT[0][i] = Integer.MAX_VALUE;
        }
        
        // Κάθε πίνακας ακεραίων αρχικοποιείται με 0 σε κάθε στοιχείο λόγω κατασκευής της γλώσσας Java. Έτσι, θεωρώ την μηδενική στήλη με κάθε στοιχείο της το 0.
        // Κλάδος OPT(i, j) = 0, για j = 0.

        // Διατρέχω κάθε κελί του πίνακα και ενημερώνω τις τιμές του σύμφωνα με την την αναδρομική σχέση
        // OPT[i][j] = min(OPT[i-1][j], 1 + OPT[i][j-itemsCapacity[i-1]]) που επιλέγει, χρησιμοποιώντας προηγουμένως υπολογισμένες
        // τιμές, αν θα διαλέξει το τρέχον στοιχείο ή κάποιο/α προηγούμενο/α ενώ εξασφαλίζει ότι στο στοιχείο τελευταίας γραμμής
        // και τελευταίας στήλης θα περιέχει το αποτέλεσμα.
        for (int i = 1; i <= itemsCapacity.length; i++){

            int j = 1;

            // Στις πρώτες 1, ..., itemsCapacity[i-1] - 1 θέσεις δεν υπάρχουν λύσεις για το i-ο στοιχείο εφόσον η χωρητικότητα
            // του στοιχείου ξεπερνάει την επιθυμητή. Σε αυτή την περίπτωση, αυθαίρετα, δεν επιλέγεται το τρέχον i-ο στοιχείο.
            // Κλάδος OPT(i, j) =  OPT(i - 1, j), για capacity(i) > j.
            for (; j < itemsCapacity[i-1]; j++){
                OPT[i][j] = OPT[i-1][j];
            }

            for (; j <= containerTotalCapacity; j++){
                // Αρχικά, θεωρώ ως λύση το OPT[i-1][j]. Αν δεν είναι εφικτή ή βέλτιστη τότε θα είναι μεγαλύτερη του 1 + OPT[i][j-itemsCapacity[i-1]]
                // που θα είναι είτε βέλτιστη είτε, επίσης, μη-εφικτή.
                // Έτσι, αν το OPT[i-1][j] δεν δίνει εφικτή λύση τότε είτε η εφικτή λύση μπορεί να βρεθεί λαμβάνοντας υπόψη
                // το τρέχον στοιχείο έχοντας ελάχιστο αριθμό κουτιών το 1 + OPT[i][j-itemsCapacity[i-1]] ή, αν και το
                // OPT[i][j-itemsCapacity[i-1]] δεν οδηγεί σε εφικτή λύση τότε ούτε το OPT[i][j] δεν δίνει εφικτή λύση.

                // Η τιμή του OPT[i-1][j], δηλαδή η λύση για τα στοιχεία 1, ..., i-1 και χωρητικότητα j.
                int OPTNotTaken = OPT[i-1][j];

                // Η τιμή του 1 + OPT[i][j-itemsCapacity[i-1]], δηλαδή η λύση για τα στοιχεία 1, ..., i και χωρητικότητα j-itemsCapacity[i-1].
                // Άν το OPT[i][j-itemsCapacity[i-1]] == Integer.MAX_VALUE, δηλαδή δεν δίνει εφικτή λύση τότε το θέτω στην
                // μεγαλύτερη δυνατή ακέραια. Διαφορετικά παίρνει την τιμή που θα είχε σε άλλη περίπτωση.
                // Η χρήση if γίνεται επειδή το άθροισμα Integer.MAX_VALUE + 1 δημιουργεί πρόβλημα με τους περιορισμούς
                // των ακεραίων και δίνει αρνητικό, κάτι που θα προκύπτει μικρότερο απο οποιαδήποτε πραγματική τιμή
                // πιθανού έγκυρου αριθμού κουτιών.
                int OPTTaken;
                if (OPT[i][j-itemsCapacity[i-1]] < Integer.MAX_VALUE){
                    OPTTaken = 1 + OPT[i][j-itemsCapacity[i-1]];
                } else {
                    OPTTaken = Integer.MAX_VALUE;
                }

                // Υπολογίζω την τιμή του στοιχείου OPT[i][j].
                // Κλάδος OPT(i, j) = min( OPT(i - 1, j), 1 + OPT(i, j - capacity(i)) ), σε διαφορετικές περιπτώσεις.
                OPT[i][j] = Math.min(OPTNotTaken, OPTTaken);
            }
        }

        // Επιστροφή κατάλληλης τιμής ανάλογα με το αν υπάρχει λύση, σύμφωνα με τα σχόλια.
        // Επιστροφή δηλαδή, της λύσης έχοντας λάβει υπόψη κάθε κουτί και το σύνολο των επιλεγμένων κουτιών
        // καλύπτει πλήρως της δοθείσα χωρητικότητα ή -1 αν η λύση είναι ανέφικτη.
        if (OPT[itemsCapacity.length][containerTotalCapacity] < Integer.MAX_VALUE){ // Έλεγχος για το αν υπάρχει λύση.
            return OPT[itemsCapacity.length][containerTotalCapacity];
        } else {
            return -1; // Η "λύση" είναι άπειρη άρα δεν είναι εφικτή.
        }
    }

    /**
     * Λύνει το δεύτερο ζητούμενο της παραλλαγής του προβλήματος του σακιδίου που αρμόζει στην άσκηση.
     *
     * Συγκεκριμένα, υπολογίζει το ελάχιστο πλήθος των κουτιών που απαιτούνται για να γεμίσει πλήρως το εμπορευματοκιβώτιο
     * λαμβάνοντας υπόψη τις ποσότητες που δίνονται [bounded case].
     *
     * Ο αλγόριθμος που χρησιμοποιείται είναι βασισμένος στον αλγόριθμο του σακιδίου με διαφορές όμως στο ότι ένα αντικείμενο
     * μπορεί να παρευρεθεί πολλές φορές (μέχρι ένα μέγιστο πλήθος το οποίο δίνεται) και ότι το σύνολο των βαρών (εδώ το
     * σύνολο των χωρητικοτήτων) να ισούται με το μέγιστο επιτρεπόμενο βάρος του σακιδίου (εδώ χωρητικότητα εμπορευματοκιβωτίου).
     * Αυτός, υπολογίζει τον ελάχιστο αριθμό αντικειμένων που απαιτούνται για να "γεμίσει" το σακίδιο (εμπορευματοκιβώτιο) ή,
     * σε περίπτωση που αυτό δεν είναι δυνατόν να σηματοδοτείται το γεγονός αυτό.
     *
     * Για να επιτευχθεί το παραπάνω, τροποποιώ τον αλγόριθμό του σακιδίου ώστε η πρώτη γραμμή του να έχει άπειρο από την
     * πρώτη στήλη και έπειτα ώστε να εντοπίζονται οι περιπτώσεις που είναι αδύνατες. Επίσης, αντί για μέγιστη αξία που μετράει
     * ο κλασσικός αλγόριθμος, εδώ μετράται το ελάχιστο πλήθος κουτιών.
     * Τέλος, για να μπορέσει ένα κουτί να παρευρεθεί πολλές φορές, απλά το εισάγω πολλές φορές σαν ξεχωριστό κουτί.
     *
     * Συγκεκριμένα, χρησιμοποιείται η bottom-up εκδοχή του που χρησιμοποιεί έναν πίνακα για να αποθηκεύσει τα ενδιάμεσα αποτελέσματα
     * της αναδρομικής εξίσωσης:                { άπειρο, άν η λύση είναι ανέφικτη σύμφωνα με τον ορισμό του προβλήματος δηλαδή για i = 0, j >= 1.
     *                              OPT(i, j) = { 0, για j = 0.
     *                                          { OPT(i - 1, j), για capacity(i) > j.
     *                                          { min( OPT(i - 1, j), 1 + OPT(i - 1, j - capacity(i)) ), σε διαφορετικές περιπτώσεις.
     *
     * Ως i-ο κουτί (ή στοιχείο) θεωρείται το κουτί το οποίο έχει το (i+1)-ο βάρος στον πίνακα με τα βάρη κάθε κουτιού. Υπενθυμίζεται ότι εφόσον κάθε κουτί μπορεί
     *  να εισαχθεί παραπάνω της μίας φοράς στον πίνακα βαρών ως ξεχωριστό κουτί, το i-ο στοιχείο του πίνακα OPT δεν αντιστοιχεί απαραίτητα στο i-ο
     *  αντικείμενο που δίνεται ως είσοδος.
     *
     * Η εξίσωση αυτή δίνει τον αριθμό ελάχιστο αριθμό κουτιών λαμβάνοντας υπόψη τα στοιχεία 1, ..., i και χωρητικότητα j.
     * 
     * Ο πρώτος κλάδος της εξίσωσης ορίζει τις αδύνατες αρχικά περιπτώσεις που "μεταδίδονται" και στις υπόλοιπες που προκύπτουν στην πορεία.
     * Ο δεύτερος, για την τετριμμένη περίπτωση της κάλυψης μηδενικής χωρητικότητας με μηδενικά κουτιά.
     * Ο τρίτος, για αυθαίρετη μη-επιλογή i-ου στοιχείου από τον αλγόριθμο εφόσον δεν μπορεί αυτό να γίνει λόγω φυσικού περιορισμού.
     * Ο τέταρτος, για επιλογή από τον αλγόριθμο για το αν συμφέρει η επιλογή i-ου στοιχείου ή όχι και επιλογή πιο συμφέρουσας 
     *  (με μικρότερο αριθμό κουτιών) λύσης.
     *
     * @param containerTotalCapacity η διαθέσιμη χωρητικότητα του εμπορευματοκιβωτίου που πρέπει να γεμίσει πλήρως.
     * @param itemsCapacity πίνακας με ζεύγη χωρητικότητας και μέγιστο αριθμός κουτιών, για κάθε τύπο κουτιών.
     *                   Η κάθε γραμμή αντιστοιχεί στο ζεύγος αυτό του εκάστοτε τύπου κουτιού και το πρώτο στοιχείο (0-η στήλη) του
     *                   ζεύγους αντιστοιχεί στην χωρητικότητα του τύπου και του δεύτερο (1-η στήλη) τον μέγιστο αριθμό εμφάνισης.
     *                   Σημειώνεται πως η εκάστοτε i-η γραμμή αφορά το (i+1)-οστό αντικείμενο.
     * @return το ελάχιστο πλήθος των κουτιών που απαιτούνται για να γεμίσει πλήρως το εμπορευματοκιβώτιο. Άν το πρόβλημα
     * δεν λύνεται, επιστρέφεται -1.
     */
    public static int solveKnapsackLimited(int containerTotalCapacity, int[][] itemsCapacity){
        // Πίνακας που αποθηκεύει την χωρητικότητα του κάθε κουτιού.
        // Τύπου ArrayList εφόσον δεν γνωρίζουμε εκ των προτέρων το πλήθος των στοιχείων του τελικού πίνακα βαρών.
        ArrayList<Integer> capacities = new ArrayList<>();

        // Εισάγω πολλές φορές το αντικείμενο.
        for (int[] pairs : itemsCapacity){

            // Για λόγους απόδοσης, εισάγεται ο μικρότερος αριθμός κουτιών ώστε να λυθεί το πρόβλημα.
            // Αυτό επιτυγχάνεται με την εισαγωγή του ελαχίστου του δοθέντος πλήθους με το πηλίκο της μέγιστης χωρητικότητας
            // του εμπορευματοκιβωτίου με την χωρητικότητα του εκάστοτε κουτιού. Το πηλίκο αυτό είναι ο θεωρητικά μέγιστος
            // αριθμός κουτιών που μπορούν να χωρέσουν στο εμπορευματοκιβώτιο ανεξάρτητα από το δοθέν πλήθος.
            int iEnd = Math.min(pairs[1], containerTotalCapacity/pairs[0]);

            for (int i = 0; i < iEnd; i++){
                capacities.add(pairs[0]);
            }
        }

        // Στον κλασσικό αλγόριθμο, έχουμε έναν πίνακα OPT[i][j] που περιέχει το ελάχιστο πλήθος των κουτιών έχοντας λάβει υπόψη το
        // στοιχείο i και με j την χωρητικότητα που καλύπτεται. Άν κάποιο στοιχείο OPT[i][j] έχει τιμή Integer.MAX_VALUE
        // (στην πράξη δεν υπάρχει το άπειρο οπότε χρησιμοποιώ την μεγαλύτερη δυνατή τιμή ακεραίου), αυτό σηματοδοτεί ότι
        // είναι αδύνατη κάλυψη χωρητικότητας j χρησιμοποιώντας τα στοιχεία 1, ..., i.
        // Έχει μέγεθος (capacities.size() + 1)x(containerTotalCapacity + 1), δηλαδή πλήθος γραμμών ίσο με τα στοιχεία και πλήθος στηλών
        // ίσο με την χωρητικότητα που καλούμαστε να καλύψουμε, αν αγνοήσουμε την πρώτη γραμμή και πρώτη στήλη.
        //
        // Στο συγκεκριμένο πρόβλημα όμως, για εξοικονόμηση μνήμης, εφόσον σε κάθε βήμα του αλγορίθμου η αναδρομική συνάρτηση που καλείται να υπολογίσει
        // ο αλγόριθμος εντός της επανάληψης είναι η: OPT(i, j) = 
        // άπειρο ή 0 ή OPT(i - 1, j)  ή  min( OPT(i - 1, j), 1 + OPT(i - 1, j - capacity(i)) ), δηλαδή σε κάθε βήμα μας "ενδιαφέρουν" το πολύ η τρέχουσα γραμμή i
        // και η προηγούμενη i-1.
        // Άρα, αντί ενός πίνακα (capacities.size() + 1)x(containerTotalCapacity + 1) αρκεί να διατηρούμε απλώς δύο γραμμές αποθηκευμένες σε δύο πίνακες
        // μεγέθους (containerTotalCapacity + 1).
        // Ο πίνακας OPTOld αντιστοιχεί στην γραμμή i-1 και ο OPTNew στην γραμμή i
        int[] OPTOld = new int[containerTotalCapacity + 1], OPTNew = new int[containerTotalCapacity + 1];

        // Η πρώτη γραμμή, εξ' ορισμού, αντιστοιχεί στο μηδενικό στοιχείο και, εφόσον δεν υπάρχει, δεν μπορεί να ληφθεί
        // υπόψη προς επιλογή. Εξαίρεση το πρώτο στοιχείο πρώτης γραμμής που, προφανώς, είναι δυνατή η κάλυψη μηδενικής
        // χωρητικότητας με μηδενικά κουτιά.
        // Κλάδος OPT(i, j) = άπειρο, άν η λύση είναι ανέφικτη σύμφωνα με τον ορισμό του προβλήματος δηλαδή για i = 0, j >= 1. 
        for(int i = 1; i <= containerTotalCapacity; i++){
            OPTOld[i] = Integer.MAX_VALUE;
        }
        
        // Κάθε πίνακας ακεραίων αρχικοποιείται με 0 σε κάθε στοιχείο λόγω κατασκευής της γλώσσας Java. Έτσι, θεωρώ την μηδενική στήλη με κάθε στοιχείο της το 0.
        // Κλάδος OPT(i, j) = 0, για j = 0.

        // Διατρέχω κάθε κελί του πίνακα και ενημερώνω τις τιμές του σύμφωνα με την την αναδρομική σχέση
        // OPT[i][j] = min(OPT[i-1][j], 1 + OPT[i-1][j-itemsCapacity[i-1]]) η οποία στην τρέχουσα εκδοχή γίνεται
        // OPTNew[j] = min(OPTOld[j], 1 + OPTOld[j-itemsCapacity[i-1]])
        // που επιλέγει, χρησιμοποιώντας προηγουμένως υπολογισμένες τιμές αν θα διαλέξει το τρέχον στοιχείο ή κάποιο/α
        // προηγούμενο/α ενώ εξασφαλίζει ότι στο στοιχείο τελευταίας γραμμής και τελευταίας στήλης θα περιέχει το αποτέλεσμα.
        for (int i = 0; i < capacities.size(); i++){

            int j = 0;

            // Στις πρώτες 1, ..., itemsCapacity[i-1] - 1 θέσεις δεν υπάρχουν λύσεις για το i-ο στοιχείο εφόσον η χωρητικότητα
            // του στοιχείου ξεπερνάει την επιθυμητή. Σε αυτή την περίπτωση, αυθαίρετα, δεν επιλέγεται το τρέχον i-ο στοιχείο.
            // Κλάδος OPT(i, j) =  OPT(i - 1, j), για capacity(i) > j.
            for (; j < capacities.get(i); j++){
                OPTNew[j] = OPTOld[j];
            }

            for (; j <= containerTotalCapacity; j++){
                // Αρχικά, θεωρώ ως λύση το OPT[i-1][j] (OPTOld[j]). Αν δεν είναι εφικτή ή βέλτιστη τότε θα είναι μεγαλύτερη του 1 + OPT[i][j-itemsCapacity[i-1]]
                // (1 + OPTOld[j-itemsCapacity[i-1]]) που θα είναι είτε βέλτιστη είτε, επίσης, μη-εφικτή.
                // Έτσι, αν το το OPT[i-1][j] (OPTOld[j]) δεν δίνει εφικτή λύση τότε είτε η εφικτή λύση μπορεί να βρεθεί λαμβάνοντας υπόψη
                // το τρέχον στοιχείο έχοντας ελάχιστο αριθμό κουτιών το 1 + OPT[i-1][j-itemsCapacity[i-1]] (1 + OPTOld[j-itemsCapacity[i-1]]) ή, αν και το
                // OPT[i-1][j-itemsCapacity[i-1]] (OPTOld[j-itemsCapacity[i-1]]) δεν οδηγεί σε εφικτή λύση τότε ούτε το OPT[i][j] (OPTNew[j]) δεν δίνει εφικτή λύση.

                // Η τιμή του OPTOld[j], δηλαδή η λύση για τα στοιχεία 1, ..., i-1 και χωρητικότητα j.
                int OPTNotTaken = OPTOld[j];

                // Η τιμή του 1 + OPTOld[j-itemsCapacity[i-1]], δηλαδή η λύση για τα στοιχεία 1, ..., i και χωρητικότητα j-itemsCapacity[i-1].
                // Άν το OPTOld[j-itemsCapacity[i-1]] == Integer.MAX_VALUE, δηλαδή δεν δίνει εφικτή λύση τότε το θέτω στην
                // μεγαλύτερη δυνατή ακέραια. Διαφορετικά παίρνει την τιμή που θα είχε σε άλλη περίπτωση.
                // Η χρήση if γίνεται επειδή το άθροισμα Integer.MAX_VALUE + 1 δημιουργεί πρόβλημα με τους περιορισμούς
                // των ακεραίων και δίνει αρνητικό, κάτι που θα προκύπτει μικρότερο απο οποιαδήποτε πραγματική τιμή
                // πιθανού έγκυρου αριθμού κουτιών.
                int OPTTaken;
                // Έλεγχος εγκυρότητας και του αν επιτρέπεται να χρησιμοποιηθεί το κουτί αυτού του τύπου.
                if (OPTOld[j- capacities.get(i)] < Integer.MAX_VALUE){
                    OPTTaken = 1 + OPTOld[j-capacities.get(i)];
                } else {
                    OPTTaken = Integer.MAX_VALUE;
                }

                // Υπολογίζω την τιμή του στοιχείου OPTNew[j].
                // Κλάδος OPT(i, j) = min( OPT(i - 1, j), 1 + OPT(i - 1, j - capacity(i)) ), σε διαφορετικές περιπτώσεις.
                OPTNew[j] = Math.min(OPTNotTaken, OPTTaken);
                
                
            }

            // Ενδιάμεση μεταβλητή για ανταλλαγή δύο πινάκων.
            // Εφόσον σε κάθε βήμα χρησιμοποιώ έναν πίνακα και αγνοώ έναν άλλο του ίδιου μεγέθους, τότε είναι πιο αποδοτικό
            // απλά να ανταλλάξω τους δύο δείκτες των πινάκων.
            int[] temp;

            temp = OPTOld;
            OPTOld = OPTNew;
            OPTNew = temp;
        }

        // Επιστροφή κατάλληλης τιμής ανάλογα με το αν υπάρχει λύση, σύμφωνα με τα σχόλια.
        // Επιστροφή δηλαδή, της λύσης έχοντας λάβει υπόψη κάθε κουτί και το σύνολο των επιλεγμένων κουτιών
        // καλύπτει πλήρως της δοθείσα χωρητικότητα ή -1 αν η λύση είναι ανέφικτη.
        if (OPTOld[containerTotalCapacity] < Integer.MAX_VALUE){ // Έλεγχος για το αν υπάρχει λύση.
            return OPTOld[containerTotalCapacity];
        } else { // Η "λύση" είναι άπειρη άρα δεν είναι εφικτή.
            return -1;
        }
    }

    public static void main(String[] args) {
        try (Scanner input = new Scanner(new BufferedReader(new FileReader(args[0])))){
            int totalCapacity = Integer.parseInt(input.nextLine()); // Διαβάζω χωρητικότητα εμπορευματοκιβωτίου.

            int boxTypeNumber = Integer.parseInt(input.nextLine()); // Διαβάζω πλήθος των διαθέσιμων τύπων κουτιών.

            // Πίνακας που περιέχει την χωρητικότητα κάθε τύπου κουτιού.
            // Ο τύπος του κουτιού αντιστοιχεί σε θέση στον πίνακα + 1. Δηλαδή το 1ο κουτί στην θέση 0 κ.ο.κ.
            // Χρήση για περίπτωση α) θεωρώντας άπειρες ποσότητες κουτιών (αγνοώντας δηλαδή τις διαθέσιμες ποσότητες)
            // [unbounded case]
            int[] eachTypeCapacity = new int[boxTypeNumber];

            // Πίνακας που περιέχει την χωρητικότητα κάθε τύπου κουτιού και ποσότητα στην οποία είναι διαθέσιμο στην πρώτη
            // στήλη και δεύτερη στήλη αντίστοιχα.
            // Ο τύπος του κουτιού αντιστοιχεί σε γραμμή στον πίνακα + 1. Δηλαδή το 1ο κουτί στην γραμμή 0 κ.ο.κ.
            // Χρήση για περίπτωση β) λαμβάνοντας υπόψη τις ποσότητες που δίνονται [bounded case].
            int[][] eachTypeCapacityAndNumber = new int[boxTypeNumber][2];

            // Για κάθε τύπο κουτιού καταγράφω δεδομένα
            for (int i = 0; i < boxTypeNumber; i++){
                Scanner line = new Scanner(input.nextLine()); // Διαβάζω μία-μία τις γραμμές και τις χειρίζομαι με Scanner.

                line.nextInt(); // Ο τύπος του κουτιού δεν ενδιαφέρει την διαδικασία υπολογισμού του αποτελέσματος και για
                                // αυτό τον αγνοούμε. Η πληροφορία δεν χάνεται βέβαια και κωδικοποιείται στις γραμμές του εκάστοτε πίνακα.

                int boxCapacity = line.nextInt(); // Αποθηκεύω χωρητικότητα κάθε κουτιού.
                int boxNumber = line.nextInt(); // Αποθηκεύω ποσότητα στην οποία είναι διαθέσιμο.

                eachTypeCapacity[i] = boxCapacity;

                eachTypeCapacityAndNumber[i][0] = boxCapacity;
                eachTypeCapacityAndNumber[i][1] = boxNumber;
            }

            // Υπολογισμό α περίπτωσης.
            int caseA = solveKnapsackUnlimited(totalCapacity, eachTypeCapacity);
            if (caseA == -1){
                System.out.println("There is no solution for the unbounded case.");
            } else {
                System.out.printf("The minimum number of boxes for the unbounded case is: %d%n", caseA);
            }

            // Υπολογισμό β περίπτωσης.
            int caseB = solveKnapsackLimited(totalCapacity, eachTypeCapacityAndNumber);
            if (caseB == -1){
                System.out.println("There is no solution for the bounded case.");
            } else {
                System.out.printf("The minimum number of boxes for the bounded case is: %d%n", caseB);
            }

        } catch (Exception e){ // Σε περίπτωση σφάλματος, τυπώνω το πρόβλημα στην προκαθορισμένη έξοδο.
            e.printStackTrace();
        }
    }
}
